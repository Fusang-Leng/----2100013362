# 数算笔试

- #### 数据结构基础各种概念

- 数据结构(data structure)就是数据的组织和存储形式。描述一个数据结构，需要指出其逻辑结构、存储结构和可进行的操作。

  **数据的逻辑结构：**从逻辑上描述结点之间的关系，和数据的存储方式无关。

集合结构：结点之间没有什么关系，只是属于同一集合。如set。

线性结构：除了最靠前的结点，每个结点有唯一前驱结点；除了最靠后的结点，每个结点有唯一后继结点。常见的有线性表、栈、队列、串

树结构：有且仅有一个结点称为”根结点”，其没有前驱(父结点)；有若干个结点称为 “叶结点”，没有后继(子结点)；其它结点有唯一前驱，有1个或多个后继。如家谱 

图结构：每个结点都可以有任意多个前驱和后继，两个结点还可以互为前驱后继。如铁路网，车站是结点。 

**数据的存储结构：**

数据在物理存储器上存储的方式，大部分情况下指的是数据在内存中存储的方式。

顺序结构：结点在内存中连续存放，所有结点占据一片连续的内存空间。如list。

链接结构：结点在内存中可不连续存放，每个结点中存有指针指向其前驱结点和/或后继结点。如链表，树。顺序表和链表是线性表的具体实现，所以是存储结构

索引结构：将结点的关键字信息（比如学生的学号）拿出来单独存储，并且为每个关键字x配一个指针指向关键字为x的结点，这样便于按照关键字查找到相应的结点。

散列结构：设置散列函数，散列函数以结点的关键字为参数，算出一个结点的存储位置。

**运算及算法：** 运算及算法是指在数据结构上定义的一组基本操作，以及在这些操作上实现的算法。常见的数据结构操作包括查找、插入、删除等。算法则是对这些操作的具体实现方式，通过选择合适的算法可以提高数据结构的效率。

### 1、各种排序算法

![排序算法对比](https://www.hello-algo.com/chapter_sorting/summary.assets/sorting_algorithms_comparison.png)

![image-20240617225832090](C:\Users\Catherineee\AppData\Roaming\Typora\typora-user-images\image-20240617225832090.png)

堆排序的时间复杂度最小是：O(n)

### 2、环形链表

环形队列中元素的数量可以通过以下公式计算：

队列元素数量=(rear−front+容量) % 容量

### 3、树的度数的求法

2n2 + n1 + 1 = n2 + n1 + n0

- 一棵树的度是指该树中节点的最大子节点个数。
- 树中的节点度数总和等于边数总和的两倍。
- 对于一棵树，边数 = 节点数 - 1，如果是二叉树对于一个二叉树，所有节点的度数总和等于边的总数。边的总数是节点总数减去 1
- 叶子节点的度数为0![image-20240617230248528](C:\Users\Catherineee\AppData\Roaming\Typora\typora-user-images\image-20240617230248528.png)

在一棵二叉树中，我们可以使用以下关系来计算不同度数结点的数量：

1. **总节点数公式**：
\[ N = L + I_1 + I_2 \]
其中，\( N \) 是总节点数，\( L \) 是叶子结点数，\( I_1 \) 是度为 1 的结点数，\( I_2 \) 是度为 2 的结点数。

2. **二叉树的性质**：
对于一棵二叉树，度为 0（叶子结点）的数目和度为 2 的结点数之间的关系是：
\[ N = I_2 + L - 1 + I_1 \]

根据题目中的信息：
- 总节点数 \( N = 101 \)
- 叶子结点数 \( L = 36 \)

我们可以用公式来找出度为 2 的结点数 \( I_2 \) 和度为 1 的结点数 \( I_1 \)：

根据二叉树的性质，度为 1 和 2 的结点数之和加上 1 等于叶子结点数：

\[ I_1 + 2I_2 = 100 - 36 + 1 = 65 \]

我们有两个方程：
\[ N = L + I_1 + I_2 \]
\[ 101 = 36 + I_1 + I_2 \]
\[ 65 = I_1 + 2I_2 \]

先解第一个方程：
\[ 101 = 36 + I_1 + I_2 \]
\[ 65 = I_1 + I_2 \]
由此可得：
\[ I_1 + I_2 = 65 \]

代入第二个方程：
\[ I_1 + 2I_2 = 65 \]

我们可以通过解这个二元一次方程组来求出 \( I_1 \) 和 \( I_2 \)：

减去第一个方程从第二个方程：
\[ (I_1 + 2I_2) - (I_1 + I_2) = 65 - 65 \]
\[ I_2 = 65 - 65 = 35 \]

所以：
\[ I_1 = 65 - 35 = 30 \]

因此：
- 度为 2 的结点个数是 35
- 度为 1 的结点个数是 30

### 4、图的连通

强连通：**强连通图的性质**：为了保证每对顶点之间都存在路径，图中至少需要有一个环路结构，使得每个顶点都可以到达其他顶点。

当然，这里是有向图的强连通和无向图的弱连通的解释：

### 有向图的强连通（Strongly Connected in Directed Graphs）

一个有向图（Directed Graph）被称为强连通图（Strongly Connected），如果对于图中的任意两个顶点 \(u\) 和 \(v\)，都有从 \(u\) 到 \(v\) 和从 \(v\) 到 \(u\) 的路径。换句话说，图中的每一对顶点之间都存在双向可达性。

**性质**：
- 强连通图的每一个顶点都可以通过有向边到达其他所有顶点。
- 强连通图中的任意两个顶点之间都存在路径。

**示例**：
考虑一个有向图 \(G\)：

\[ V = \{ A, B, C \} \]
\[ E = \{ (A \to B), (B \to C), (C \to A) \} \]

这个图是强连通的，因为：
- 从 \(A\) 可以到 \(B\) 和 \(C\)
- 从 \(B\) 可以到 \(C\) 和 \(A\)
- 从 \(C\) 可以到 \(A\) 和 \(B\)

### 无向图的弱连通（Weakly Connected in Undirected Graphs）

无向图（Undirected Graph）的弱连通性是指图中的每一对顶点之间都至少存在一条路径。换句话说，如果将无向图的所有边看作无向的，则图是连通的。

**性质**：

- 弱连通图的每一对顶点之间至少存在一条路径。
- 弱连通性只考虑图的连通性，不要求有向路径。

**示例**：
考虑一个无向图 \(G\)：

\[ V = \{ A, B, C, D \} \]
\[ E = \{ (A - B), (B - C), (C - D) \} \]

这个图是弱连通的，因为：
- 从 \(A\) 可以到 \(B\)
- 从 \(B\) 可以到 \(C\)
- 从 \(C\) 可以到 \(D\)

尽管从 \(A\) 不能直接到 \(D\)，但通过中间节点可以达到所有节点，因此是连通的。

### 对比总结

- **强连通（有向图）**：每对顶点之间都有双向路径。
- **弱连通（无向图）**：每对顶点之间至少有一条路径（无向）。

### 具体应用

- **强连通图**在有向网络中，如道路网、互联网中的路径查找，确保从任意一点能到达其他任意一点，反之亦然。
- **弱连通图**用于一般的连通性检查，如社交网络中是否所有用户间可以通过朋友的朋友等关系相连。



1. **连通分量（Connected Component）：** 在无向图中，一个连通分量是指图中的一个极大连通子图，其中的任意两个节点都可以通过图中的边互相到达。连通分量可以理解为无向图的极大连通子图。
2. **强连通分量（Strongly Connected Component）：** 在有向图中，一个强连通分量是指图中的一个极大子图，其中的任意两个节点都可以通过有向路径互相到达。强连通分量可以理解为有向图的极大连通子图。

强连通分量是针对有向图而言的，而连通分量是针对无向图而言的。因此，它们的定义和性质有所不同。

### 5、图的各种遍历

#### Dijkstra

迪杰斯特拉算法（Dijkstra's Algorithm）是一种经典的单源最短路径算法，用于计算一个图中从起始顶点到所有其他顶点的最短路径。该算法由荷兰计算机科学家艾兹赫尔·迪杰斯特拉于1956年提出，并于1959年正式发表。迪杰斯特拉算法适用于带权有向图和无向图，但权值必须是非负的。

### 算法思想

迪杰斯特拉算法的核心思想是贪心策略。它通过不断选择具有最小已知距离的顶点，逐步扩展最短路径树，直到所有顶点都被处理。

### 算法步骤

1. **初始化**：

   - 将起始顶点的距离设置为0。
   - 将所有其他顶点的距离设置为正无穷大（表示尚未访问）。
   - 将所有顶点标记为未访问。
   - 创建一个优先队列（通常实现为最小堆），初始时将起始顶点插入队列。

2. **选择顶点**：

   - 从优先队列中取出具有最小距离的顶点，标记为已访问。

3. **更新邻接顶点**：

   - 对于当前顶点的每一个邻接顶点，如果通过当前顶点到达邻接顶点的路径比已知的最短路径更短，则更新该邻接顶点的距离，并将该邻接顶点插入优先队列。

4. **重复**：

   - 重复步骤2和3，直到所有顶点都被标记为已访问或优先队列为空。

5. **结果**：

   - 最终，每个顶点的距离值表示从起始顶点到该顶点的最短路径长度。

   - 下列关于最短路算法的说法正确的有（ A, C ） ：

     A: 当图中不存在负权回路但是存在负权边时， Dijkstra 算法不一定能求出源点到所有点的最短路。

     B: 当图中存在负权回路时， Dijkstra 算法也一定能求出源点到所有点的最短路。 C: 当图中不存在负权边时， Dijkstra 算法能求出每对顶点间最短路径. D: Dijkstra 算法不能用于每对顶点间最短路计算。

Kruskal算法和Prim算法是用于求解最小生成树（Minimum Spanning Tree, MST）的两种经典算法。最小生成树是指在一个加权连通图中，选择若干条边，使得所有节点连通且边权值之和最小。这两种算法的思想和目的如下：

### Kruskal算法

#### 思想

Kruskal算法的基本思想是贪心策略。它通过从权值最小的边开始，逐步将边加入到最小生成树中，同时确保不会形成环，直到生成树包含所有顶点。

#### 步骤

1. **排序**：将所有边按权值从小到大排序。
2. **初始化**：初始化一个空集合来存储最小生成树的边。
3. **逐条添加边**：从权值最小的边开始，逐条检查是否可以添加到最小生成树中。具体地，使用并查集（Union-Find）数据结构来判断是否会形成环。
4. **形成树**：重复添加边的过程，直到树包含所有顶点。

### Prim算法

#### 思想

Prim算法的基本思想也是贪心策略。它通过从一个起始顶点开始，逐步扩展最小生成树，每次选择权值最小且不会形成环的边，将新顶点加入生成树。

#### 步骤

1. **初始化**：选择一个顶点作为起始顶点，并将其标记为已访问。
2. **选择最小边**：在所有从已访问顶点到未访问顶点的边中，选择权值最小的一条边，并将相应的顶点加入生成树。
3. **重复**：重复选择最小边和加入新顶点的过程，直到所有顶点都被访问。

### 比较

1. **Kruskal算法**：适用于稀疏图。使用边来构建最小生成树，从最小的边开始，逐条添加，使用并查集来防止形成环。
2. **Prim算法**：适用于稠密图。使用顶点来构建最小生成树，从起始顶点开始，逐步扩展，使用优先队列来选择最小的边。

这两种算法都是解决最小生成树问题的有效方法，选择哪种算法取决于具体图的特性以及实际应用的需求。

### 6、循环队列

循环队列（Circular Queue）是一种基于数组的队列实现方式，具有固定的最大容量。在循环队列中，队列的前后两端相连，形成一个环状结构。这种设计可以有效利用数组空间，避免因队列操作而频繁的数组移动操作。循环队列主要通过两个指针来管理队列中的元素：队头指针（front）和队尾指针（rear）。

### 循环队列的基本概念

1. **队头指针 (front)**：指向队列中第一个元素的位置。
2. **队尾指针 (rear)**：指向队列中下一个可以插入新元素的位置。
3. **队列的最大容量 (n)**：数组的大小，也就是队列中最多可以容纳的元素数量。

### 条件判断

1. 队空条件
   - 当队列为空时，队头指针和队尾指针指向同一个位置。
   - 条件：`front == rear`
2. 队满条件
   - 当队列满时，队尾指针的下一个位置将是队头指针的位置。
   - 条件：`(rear + 1) % n == front`

```python
class CircularQueue:
    def __init__(self, n):
        self.queue = [None] * n
        self.front = 0
        self.rear = 0
        self.max_size = n
def enqueue(self, element):
    if (self.rear + 1) % self.max_size == self.front:
        raise Exception("Queue is full")
    self.queue[self.rear] = element
    self.rear = (self.rear + 1) % self.max_size

def dequeue(self):
    if self.front == self.rear:
        raise Exception("Queue is empty")
    element = self.queue[self.front]
    self.front = (self.front + 1) % self.max_size
    return element

def is_empty(self):
    return self.front == self.rear

def is_full(self):
    return (self.rear + 1) % self.max_size == self.front

def size(self):
    return (self.rear - self.front + self.max_size) % self.max_size
```

### 7、森林与树

森林的前序遍历序列，和其儿子兄弟树的前序遍历序列一致。森林的后序遍历序列，和其儿子兄弟树的中序遍历序列一致。

一个二叉树是二叉搜索树，当且仅当其中序遍历序列是递增序列

### 8、散列表

双散列法（Double Hashing）是一种解决哈希表中的碰撞（冲突）问题的开放地址方法。开放地址法是一种处理哈希冲突的方法，在这种方法中，当冲突发生时，程序会在哈希表中寻找一个新的位置来存储冲突的元素，而不是将它们存储在一个链表或其他结构中。

双散列法的基本思想是使用两个不同的哈希函数来计算冲突发生时的新位置。具体步骤如下：

1. **哈希函数定义**：
   - 第一个哈希函数 \( h_1(k) \) 用于确定元素的初始位置。
   - 第二个哈希函数 \( h_2(k) \) 用于确定碰撞后重新探测的位置增量。

2. **插入操作**：
   当需要插入一个键 \( k \) 时：
   - 计算初始位置：\( i = h_1(k) \)
   - 如果位置 \( i \) 已经被占用，计算新的位置：\( i = (h_1(k) + j \cdot h_2(k)) \% m \)，其中 \( j \) 是冲突次数， \( m \) 是哈希表的大小。

3. **哈希函数的选择**：
   - \( h_1(k) \) 通常是一个常见的哈希函数，将键 \( k \) 映射到哈希表的索引。
   - \( h_2(k) \) 应该确保在哈希表中探测所有位置，以避免无限循环。通常选择一个与表大小 \( m \) 互质的函数，例如： \( h_2(k) = 1 + (k \% (m - 1)) \)。

4. **查找操作**：
   类似于插入操作，当查找一个键 \( k \) 时：
   - 计算初始位置：\( i = h_1(k) \)
   - 如果位置 \( i \) 不匹配，则按以下方式重新探测：\( i = (h_1(k) + j \cdot h_2(k)) \% m \)，直到找到匹配的键或探测到空位置（表示查找失败）。

5. **删除操作**：
   双散列法中删除操作通常比较复杂，因为删除一个元素后，可能会破坏查找路径，影响后续的查找操作。因此，有时会使用标记删除（lazy deletion）的方法，即在删除时标记该位置为空但保留原有哈希信息，以便继续进行查找操作。

### 示例

假设我们有一个大小为 11 的哈希表（即 \( m = 11 \)），哈希函数定义如下：
- \( h_1(k) = k \% 11 \)
- \( h_2(k) = 1 + (k \% 10) \)

当我们插入键 \( k = 27 \) 时：
- 计算初始位置：\( h_1(27) = 27 \% 11 = 5 \)
- 如果位置 5 已被占用，计算新位置：\( h_2(27) = 1 + (27 \% 10) = 1 + 7 = 8 \)

所以，新位置为：\( i = (5 + j \cdot 8) \% 11 \)，根据冲突次数 \( j \) 进行探测。

通过双散列法，我们可以有效地减少冲突带来的性能影响，提高哈希表的查找和插入效率。

### 9、堆

要用筛选法构建最小值堆，首先要了解最小值堆的特性：每个节点的键值都小于或等于其子节点的键值。为了构建最小值堆，我们通常从最后一个非叶子节点开始，一直到根节点，依次对每个节点进行下沉操作。         

![image-20240618130932554](C:\Users\Catherineee\AppData\Roaming\Typora\typora-user-images\image-20240618130932554.png)

交换元素为 73/12, 26/15, 52/40, 64/12, 38/12, 38/15, 38/26

堆（Heap）是一种特殊的树形数据结构，通常用来实现优先队列。堆分为两种：最大堆（Max-Heap）和最小堆（Min-Heap）。堆具有以下特点：

1. **完全二叉树**：堆是一棵完全二叉树，即除了最后一层外，其他每一层都是满的，最后一层的所有结点尽可能地靠左排列。
2. **堆性质**：
   - **最大堆**：每个结点的值都大于或等于其左右孩子结点的值。
   - **最小堆**：每个结点的值都小于或等于其左右孩子结点的值。

### 最大堆和最小堆

- **最大堆**：根结点是最大值。对于任意结点 `i`，有 A[i]≥A[2i+1]A[i] \geq A[2i + 1]A[i]≥A[2i+1] 且 A[i]≥A[2i+2]A[i] \geq A[2i + 2]A[i]≥A[2i+2]。
- **最小堆**：根结点是最小值。对于任意结点 `i`，有 A[i]≤A[2i+1]A[i] \leq A[2i + 1]A[i]≤A[2i+1] 且 A[i]≤A[2i+2]A[i] \leq A[2i + 2]A[i]≤A[2i+2]。

### 操作

1. **插入（Insert）**：将一个新元素插入堆中，并保持堆性质。
   - 插入元素到堆的末尾。
   - 通过不断上移（Heapify-Up）新插入的元素，使堆保持性质。
2. **删除最大（Delete Max）或删除最小（Delete Min）**：从堆中删除最大元素（最大堆）或最小元素（最小堆），并保持堆性质。
   - 将堆顶元素与最后一个元素交换。
   - 移除最后一个元素（原堆顶元素）。
   - 通过不断下移（Heapify-Down）新堆顶元素，使堆保持性质。
3. **构建堆（Build Heap）**：将一个无序数组转换为堆。
   - 从最后一个非叶子结点开始，依次对每个结点进行下移操作。

### 时间复杂度

- **插入**：O(log⁡n)O(\log n)O(logn)，因为插入操作需要上移新插入的元素，最坏情况下需要移动到根结点。
- **删除最大/最小**：O(log⁡n)O(\log n)O(logn)，因为删除操作需要下移新堆顶元素，最坏情况下需要移动到叶子结点。
- **构建堆**：O(n)O(n)O(n)，因为从无序数组构建堆的过程通过逐步下移，每个结点最多移动几次，而不是每个结点都移动到根或叶子。

### 10、KMP

KMP算法（Knuth-Morris-Pratt算法）是一种用于在字符串中查找子字符串的高效算法。其主要思想是通过利用部分匹配表（又称为“前缀函数”或“失配函数”）来避免重复的字符比较，从而提高匹配效率。

### KMP算法的基本逻辑

1. **前缀函数（部分匹配表）**：
   - 前缀函数是一个数组，记录了每个位置之前的子串中最长的相同前缀和后缀的长度。
   - 前缀函数的计算使得在主串匹配过程中，可以直接跳过已经匹配的部分，从而避免不必要的重复比较。

2. **前缀函数的计算**：
   - 令 `pattern` 为待匹配的模式串，`prefix[i]` 表示从 `pattern[0]` 到 `pattern[i]` 的子串的最长相同前缀和后缀的长度。
   - 初始化 `prefix[0] = 0`，然后从 `i = 1` 开始计算每个位置的前缀函数值。
   - 若 `pattern[i] == pattern[length]`，则 `prefix[i] = length + 1`。
   - 否则，递归地寻找次长的前缀长度。

3. **KMP匹配过程**：
   - 使用前缀函数在主串 `text` 中进行匹配。
   - 令 `j` 为模式串的指针，初始 `j = 0`。
   - 当 `text[i] == pattern[j]` 时，两个指针都向右移动。
   - 当 `text[i] != pattern[j]` 时，根据前缀函数 `prefix[j-1]` 的值来调整 `j` 的位置，从而避免重新比较 `text` 中已经匹配过的部分。

### 示例

假设我们有主串 `text = "ababcabcabababd"` 和模式串 `pattern = "ababd"`。

1. **计算前缀函数**：
   ```plaintext
   pattern: a  b  a  b  d
   prefix:  0  0  1  2  0
   ```

2. **匹配过程**：
   - 初始化 `i = 0`, `j = 0`
   - 比较 `text[0]` 和 `pattern[0]`，相等，移动 `i` 和 `j`。
   - 比较 `text[1]` 和 `pattern[1]`，相等，移动 `i` 和 `j`。
   - 比较 `text[2]` 和 `pattern[2]`，相等，移动 `i` 和 `j`。
   - 比较 `text[3]` 和 `pattern[3]`，相等，移动 `i` 和 `j`。
   - 比较 `text[4]` 和 `pattern[4]`，不相等，使用 `prefix` 表调整 `j` 的位置到 `prefix[3] = 2`。
   - 继续匹配，直到匹配成功或遍历完主串。

```python
def compute_prefix(pattern):
    m = len(pattern)
    prefix = [0] * m
    k = 0

    for q in range(1, m):
        while k > 0 and pattern[k] != pattern[q]:
            k = prefix[k - 1]
        if pattern[k] == pattern[q]:
            k += 1
        prefix[q] = k

    return prefix

def kmp_search(text, pattern):
    n = len(text)
    m = len(pattern)
    prefix = compute_prefix(pattern)
    q = 0

    for i in range(n):
        while q > 0 and pattern[q] != text[i]:
            q = prefix[q - 1]
        if pattern[q] == text[i]:
            q += 1
        if q == m:
            print(f"Pattern occurs with shift {i - m + 1}")
            q = prefix[q - 1]

# 示例
text = "ababcabcabababd"
pattern = "ababd"
kmp_search(text, pattern)

```

### 总结

- KMP算法通过计算前缀函数，避免了在匹配失败时的重复比较。
- 时间复杂度为 \( O(n + m) \)，其中 \( n \) 是主串长度，\( m \) 是模式串长度。
- 适用于在大文本中查找模式串，提高匹配效率。

### 第4题：计算模式p = "aabcaabbaa"的Next数组

我们需要计算模式串 "aabcaabbaa" 的前缀函数数组（通常称为Next数组）。

下面是计算过程：

1. 初始状态：next[0] = 0。
2. 从模式串的第二个字符开始，依次计算每个位置的next值。

具体步骤如下：

```
plaintextCopy codep = "aabcaabbaa"

i = 1: p[1] == p[0], next[1] = next[0] + 1 = 1
i = 2: p[2] != p[1], p[2] != p[0], next[2] = 0
i = 3: p[3] != p[2], p[3] != p[0], next[3] = 0
i = 4: p[4] == p[0], next[4] = next[0] + 1 = 1
i = 5: p[5] == p[1], next[5] = next[1] + 1 = 2
i = 6: p[6] == p[2], next[6] = next[2] + 1 = 3
i = 7: p[7] != p[6], next[7] = 0
i = 8: p[8] == p[0], next[8] = next[0] + 1 = 1
i = 9: p[9] == p[1], next[9] = next[1] + 1 = 2
```

得到的Next数组为：

```
plaintext
Copy code
0 1 0 0 1 2 3 0 1 2
```

### 第5题：利用Next数组对文本t进行匹配

模式串p = "aabcaabbaa" 文本串t = "aaabaabcabaabcaabbaab"

我们使用KMP算法进行模式匹配，记录每一次字符比较。

下面是匹配过程：

```
plaintextCopy codet = "aaabaabcabaabcaabbaab"
p = "aabcaabbaa"
next = [0 1 0 0 1 2 3 0 1 2]

i = 0, j = 0: t[0] == p[0], i++, j++ (1 comparison)
i = 1, j = 1: t[1] == p[1], i++, j++ (1 comparison)
i = 2, j = 2: t[2] == p[2], i++, j++ (1 comparison)
i = 3, j = 3: t[3] != p[3], j = next[j-1] = next[2] = 0 (1 comparison)
i = 3, j = 0: t[3] == p[0], i++, j++ (1 comparison)
i = 4, j = 1: t[4] == p[1], i++, j++ (1 comparison)
i = 5, j = 2: t[5] != p[2], j = next[j-1] = next[1] = 1 (1 comparison)
i = 5, j = 1: t[5] == p[1], i++, j++ (1 comparison)
i = 6, j = 2: t[6] == p[2], i++, j++ (1 comparison)
i = 7, j = 3: t[7] == p[3], i++, j++ (1 comparison)
i = 8, j = 4: t[8] == p[4], i++, j++ (1 comparison)
i = 9, j = 5: t[9] == p[5], i++, j++ (1 comparison)
i = 10, j = 6: t[10] == p[6], i++, j++ (1 comparison)
i = 11, j = 7: t[11] == p[7], i++, j++ (1 comparison)
i = 12, j = 8: t[12] == p[8], i++, j++ (1 comparison)
i = 13, j = 9: t[13] == p[9], i++, j++ (1 comparison)
i = 14, j = 10: j == len(p), match found at i - j = 4 (total comparisons = 16)
```

继续匹配后面的部分：

```
plaintextCopy codei = 14, j = 0: t[14] == p[0], i++, j++ (1 comparison)
i = 15, j = 1: t[15] == p[1], i++, j++ (1 comparison)
i = 16, j = 2: t[16] != p[2], j = next[j-1] = next[1] = 1 (1 comparison)
i = 16, j = 1: t[16] == p[1], i++, j++ (1 comparison)
i = 17, j = 2: t[17] == p[2], i++, j++ (1 comparison)
i = 18, j = 3: t[18] == p[3], i++, j++ (1 comparison)
i = 19, j = 4: t[19] == p[4], i++, j++ (1 comparison)
i = 20, j = 5: j == len(p), match found at i - j = 15 (total comparisons = 22)
```

总结： 总共进行的字符比较次数为 22 次。